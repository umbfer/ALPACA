library(DescTools)
library(ggplot2)
library(facetscales)
library(dplyr)
library(stringr)


###### DESCRIPTION

# Produces a panel made of a set of stacked boxplots (one for each distinct value of k), for each AF.
# Each boxplot reports the distribution of the proportion of true positives, cumulatively by length,
# by considering values generated by the Alternative models, with increasing gamma,
# with respect to the Null model.

# The output is a set of PNG images with name <AFMeasure>-Allk.png, where <AFMeasure> 
# stands for the actual value of AF measure being considered


# Note: this script must be executed after RawDistances-CSV2RDS

###### OPTIONS

# Sets the path of the directory containing either the sequences under analysis or the input dataframe

setwd("~/Universita/Src/IdeaProjects/power_statistics/data/results/dataset5-1000")

# Sets the name of the file containing the input dataframe

dfFilename <- "RawDistances-All.RDS"

###### CODE

options(echo=FALSE)
args <- commandArgs(trailingOnly = TRUE)

if (length( args) < 1) {
  targetMeasures <- c('intersection', 'd2z', 'chisquare', 'd2star')
  #  cat( sprintf("Wrong number of arguments. Usage: %s targetMeasure\n", 'PlotRescaledRawDistances-AllK.R'))
  #  quit(save = "no")
} else {
  targetMeasures <- args
}



if (!file.exists(dfFilename)) {
	cat( sprintf("Input Dataframe (%s) does not exist. Exiting\n", dfFilename))
	quit(save = "no")
}

# carica il dataframe dal file
dati <- readRDS(file = dfFilename)

cat('Start plotting.\n')

# modifica i fattori di scala per ciascuna riga del pannello
# N.B. l'etichetta del pannello deve essere stringa NON numero
scales_y <- list(
    'chebyshev' = scale_y_continuous(limits = c(400, 1300)),
    'd2z' = scale_y_continuous(limits = c(135.80, 136)))

# for labels
len_names <- list(
  '2e+05' = "n = 200 000",
  '5e+06' = "n = 5 000 000")

k_names <- list(
  '4' = "k = 4",
  '5' = "k = 4",
  '6' = "k = 6",
  '8' = "k = 8",
  '10' = "k = 10",
  '11' = "k = 10")

# rename in a human readable format the measure names
measure_names <- function( measure) {
    ris <- str_to_title( switch( measure,
                 'chisquare' = 'chi square',
                 'd2star' = 'd2*',
                 'harmonicmean' = 'harmonic mean',
                 'squaredchord' = 'squared chord',
                 'jensenshannon' = 'jensen shannon',
                 measure))
  return( ris)
}


plot_labeller <- function(variable,value){
  # cat(sprintf("variable: <%s>, value: <%s>\n", variable, as.character(value)))
  if (variable == 'len') {
    # N.B. len e' un factor
    return(len_names[as.character(value)])
  } else if (variable == 'k') {
    return(k_names[as.character(value)])
  } else if (variable == 'AM + k') {
    return(k_names[as.character(value)])
  } else {
    return(as.character(value))
  }
}

# modifica i fattori di scala per ciascuna riga del pannello
scales_y <- list(
#  `4` = scale_y_continuous(limits = c(1000000, 2000000), breaks = seq(0, 0.10, 0.02)),
  `4` = scale_y_continuous(limits = c(2320000, 2380000)),
  `10` = scale_y_continuous(limits = c(2320000, 2700000)))


for( target in targetMeasures) {
    df <- filter(dati, dati$len == 5000000 & dati$Measure == target & dati$Model != 'T1' & (dati$k == 4 | dati$k == 10)) # solo una misura per 2 valori di k
    # Rescaling in a range of values
    # dfk4 <- filter(dati, dati$len == 5000000 & dati$Measure == target & dati$Model != 'T1' & dati$k == 4) # solo una misura per tutti i k
    # 
    # MinMR <- min(dfk4[grepl('^MR', dfk4$Model), "Distance"])
    # MaxMR <- max(dfk4[grepl('^MR', dfk4$Model), "Distance"])
    # MinPT <- mean(dfk4[grepl('^NM', dfk4$Model), "Distance"]) + 2000 # il max del NM e non il min di PT alziamo un po' MR
    # MaxPT <- max(dfk4[grepl('^PT', dfk4$Model), "Distance"])
    # scaleMR <- (MaxPT - MinPT) / (MaxMR - MinMR)
    # dfk4$Distance2 <- ifelse(grepl("^MR", dfk4$Model), (((dfk4$Distance - MinMR) *scaleMR) + MinPT), dfk4$Distance)
    # # dff[grepl('^MR', dff$Model), "Distance2"] <- dff[grepl('^MR', dff$Model), "Distance"] * scaleMR
    # 
    # dfk10 <- filter(dati, dati$len == 5000000 & dati$Measure == target & dati$Model != 'T1' & dati$k == 10) # solo una misura per tutti i k
    # 
    # MinMR <- min(dfk10[grepl('^MR', dfk10$Model), "Distance"])
    # MaxMR <- max(dfk10[grepl('^MR', dfk10$Model), "Distance"])
    # MinPT <- mean(dfk10[grepl('^NM', dfk10$Model), "Distance"]) + 10000
    # MaxPT <- max(dfk10[grepl('^PT', dfk10$Model), "Distance"])
    # scaleMR <- (MaxPT - MinPT) / (MaxMR - MinMR)
    # dfk10$Distance2 <- ifelse(grepl("^MR", dfk10$Model), (((dfk10$Distance - MinMR) *scaleMR) + MinPT), dfk10$Distance)
    # # dff[grepl('^MR', dff$Model), "Distance2"] <- dff[grepl('^MR', dff$Model), "Distance"] * scaleMR
    # 
    # dff <- rbind(dfk4, dfk10)

    df$AM <- grepl('^MR', df$Model) # separa i due Alternative Models MR -> TRUE
    
    dfNM <- filter(dati, dati$len == 5000000 & dati$Measure == target & dati$Model == 'NM' & (dati$k == 4 | dati$k == 10)) # Duplica il NM per ripeterlo in ogni facet
    dfNM$AM <- TRUE    
    df <- rbind(df, dfNM)
    
    if (nrow(df) < 1000) {
      cat( sprintf("Not  enough data (%d) for measure: %s\n", nrow(dff), target))
      quit(save = "no")
    }
    sp <- ggplot( df, aes(x = Model, y = Distance, fill = Model, alpha=0.7)) +
    	geom_boxplot( aes(color = Model), outlier.size = 0.3) +
      # scale_y_continuous(sec.axis = sec_axis(~ . * 10))
    	facet_grid(cols = vars( len), rows = vars( AM + k), scales = "free", labeller = plot_labeller) +
    	# facet_grid_sc(cols = vars( len), rows = vars( k), scales = list( y = scales_y)) +
    	theme_bw() + theme( axis.text.x = element_text(size = 10, angle = 45, hjust = 1)) + # axis.text.y = element_blank()) +
    	theme(legend.position = "none") + labs(x = "") + labs(y = sprintf("%s Distances", measure_names(target)))
    	# ggtitle(sprintf("Distances for k = %d", kv))
    
    
    # dev.new(width = 16, height = 9)
    outfname <- sprintf("%s-AllK.png", target)
    ggsave( outfname, device = png(), width = 6, height = 6, dpi = 300)
    # print(sp)
    cat(sprintf("%s processed\n", outfname))
    # dev.off() #only 129kb in size
}